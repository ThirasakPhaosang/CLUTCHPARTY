"use client";

import React, { useEffect, useRef, useState } from "react";
import * as PIXI from "pixi.js";
import { SPAWN_POINTS } from "@/lib/game/map";
import { GameRoom, Player } from "@/lib/types";

type RoomLike = GameRoom | (Omit<GameRoom, 'players'> & { players: Record<string, Player> });
interface GameBoardProps {
  room: RoomLike;
  speakingPeers: Record<string, boolean>;
  userNames: Record<string, string>;
}

const PLAYER_COLORS = [
  0xff0000, 0x0000ff, 0x00ff00, 0xffff00,
  0xff00ff, 0x00ffff, 0xffffff, 0x808080,
];

const BASE_W = 1920;
const BASE_H = 1600;

const GameBoard: React.FC<GameBoardProps> = ({ room, speakingPeers, userNames }) => {
  const canvasRef = useRef<HTMLDivElement>(null);
  const pixiAppRef = useRef<PIXI.Application | null>(null);
  const playerObjects = useRef<Map<string, { container: PIXI.Container, speakingIndicator: PIXI.Graphics }>>(new Map());
  const [isInitialized, setIsInitialized] = useState(false);

  useEffect(() => {
    if (!canvasRef.current) return;

    let cancelled = false;
    let didInit = false;
    let resizeHandler: (() => void) | undefined;
    let ro: ResizeObserver | undefined;

    const app = new PIXI.Application();

    (async () => {
      try {
        await app.init({
          width: BASE_W,
          height: BASE_H,
          backgroundColor: 0x1a1a1a,
          autoDensity: true,
          resolution:
            typeof window !== "undefined" ? window.devicePixelRatio || 1 : 1,
        });
      } catch {
        return;
      }

      if (cancelled) {
        try { app.ticker?.stop(); } catch {}
        try { app.stage?.removeChildren(); } catch {}
        try { app.destroy(true); } catch {}
        return;
      }
      
      pixiAppRef.current = app;
      didInit = true;

      if (canvasRef.current && canvasRef.current.childElementCount === 0) {
        canvasRef.current.appendChild(app.canvas);
      }

      const doResize = () => {
        if (!canvasRef.current || !app.stage) return;
        const parent = canvasRef.current;
        const parentWidth = parent.clientWidth;
        const parentHeight = parent.clientHeight;
        if (!parentWidth || !parentHeight) {
          // try again on next frame when layout is ready
          requestAnimationFrame(doResize);
          return;
        }
        const scale = Math.min(parentWidth / BASE_W, parentHeight / BASE_H);
        app.renderer.resize(parentWidth, parentHeight);
        app.stage.scale.set(scale);
        app.stage.x = Math.floor((parentWidth - BASE_W * scale) / 2);
        app.stage.y = Math.floor((parentHeight - BASE_H * scale) / 2);
      };
      resizeHandler = doResize;
      window.addEventListener("resize", doResize);
      // Ensure we size after layout paints
      requestAnimationFrame(doResize);

      // Observe container size changes (e.g., responsive layout panels)
      try {
        const RO = (window as unknown as { ResizeObserver?: typeof ResizeObserver }).ResizeObserver;
        if (RO) {
          ro = new RO(() => doResize());
          if (canvasRef.current) ro.observe(canvasRef.current);
        }
      } catch {}

      const background = new PIXI.Graphics();
      background.rect(0, 0, BASE_W, BASE_H).fill(0x282c34);
      const gridSize = 50;
      background.stroke({ width: 1, color: 0x444444 });
      for (let i = 0; i < BASE_W / gridSize; i++) {
        background.moveTo(i * gridSize, 0).lineTo(i * gridSize, BASE_H);
      }
      for (let i = 0; i < BASE_H / gridSize; i++) {
        background.moveTo(0, i * gridSize).lineTo(BASE_W, i * gridSize);
      }
      app.stage.addChild(background);

      setIsInitialized(true);
    })();

    return () => {
      cancelled = true;
      if (resizeHandler) window.removeEventListener("resize", resizeHandler);
      try { ro?.disconnect(); } catch {}
      const current = pixiAppRef.current;
      if (didInit) {
        try {
          if (current === app && current) {
            current.ticker?.stop();
            current.stage?.removeChildren();
            current.destroy(true);
            pixiAppRef.current = null;
          } else {
            app.ticker?.stop();
            app.stage?.removeChildren();
            app.destroy(true);
          }
        } catch {}
      }
      if (canvasRef.current) {
        while (canvasRef.current.firstChild) {
          canvasRef.current.removeChild(canvasRef.current.firstChild);
        }
      }
      playerObjects.current.clear();
      setIsInitialized(false);
    };
  }, []);

  useEffect(() => {
    const app = pixiAppRef.current;
    if (!app || !app.stage || !isInitialized) return;

    const currentPlayersOnMap = new Set(playerObjects.current.keys());
    const playersList: Player[] = Array.isArray(room.players)
      ? room.players
      : Object.values(room.players);
    const roomPlayers = new Set(playersList.map((p) => p.uid));

    currentPlayersOnMap.forEach((uid) => {
      if (!roomPlayers.has(uid)) {
        const playerObj = playerObjects.current.get(uid);
        if (playerObj) try { app.stage?.removeChild(playerObj.container); } catch {}
        playerObjects.current.delete(uid);
      }
    });

    playersList.forEach((player, index) => {
      let playerObj = playerObjects.current.get(player.uid);

      if (!playerObj) {
        const spawnPoint = SPAWN_POINTS[index % SPAWN_POINTS.length];
        const color = PLAYER_COLORS[index % PLAYER_COLORS.length];

        const container = new PIXI.Container();
        
        const speakingIndicator = new PIXI.Graphics().circle(0, 0, 20).stroke({ width: 3, color: 0x3b82f6 });
        speakingIndicator.visible = false;
        container.addChild(speakingIndicator);
        
        const pawn = new PIXI.Graphics().circle(0, 0, 15).fill(color).stroke({ width: 2, color: 0xffffff });
        container.addChild(pawn);

        const nameText = new PIXI.Text({
          text: player.displayName || userNames[player.uid] || "---",
          style: new PIXI.TextStyle({ fontFamily: "Arial", fontSize: 14, fill: "#ffffff", stroke: { color: "#000000", width: 3, join: "round" } }),
        });
        nameText.anchor.set(0.5, 0);
        nameText.y = 22;
        container.addChild(nameText);

        container.x = spawnPoint.x;
        container.y = spawnPoint.y;

        app.stage.addChild(container);
        playerObj = { container, speakingIndicator };
        playerObjects.current.set(player.uid, playerObj);
      }
      
      playerObj.container.alpha = player.status === "disconnected" ? 0.5 : 1.0;
      playerObj.speakingIndicator.visible = !!speakingPeers[player.uid];
    });

  }, [isInitialized, room.players, speakingPeers, userNames]);
  
  // Animation loop for speaking indicators
  useEffect(() => {
    const app = pixiAppRef.current;
    if (!app) return;

    let time = 0;
    const ticker = (ticker: PIXI.Ticker) => {
        time += ticker.deltaTime;
        const scale = 1 + Math.sin(time * 0.2) * 0.05;
        playerObjects.current.forEach((obj, uid) => {
            if (obj.speakingIndicator.visible) {
              obj.speakingIndicator.scale.set(scale);
              obj.speakingIndicator.alpha = 0.5 + Math.sin(time * 0.2) * 0.5;
            }
        });
    };

    app.ticker.add(ticker);
    return () => {
      try { app.ticker?.remove(ticker); } catch {}
    };
  }, [isInitialized]);

  return (
    <div className="absolute inset-0 z-0 pointer-events-none select-none">
      <div ref={canvasRef} className="w-full h-full bg-zinc-800" />
    </div>
  );
};

export default GameBoard;
